
[1장 - 들어가기]
=============   
　   
### 프로그래밍을 잘하기 위해서는

1) 언어의 핵심(객체 지향)
2) 문법, 라이브러리
3) "용법"

3가지가 모두 잘 되어야 한다.　   
이 책에서는 3번 "용법"에 대해 설명한다.
　   
    　   
       
### 제목 Effective Java의 뜻　   

자바가 1991년 만들어진 이후, 30년이 넘는 기간동안 "관례적이고 효과적인 자바 사용법"이 정립되었다. 물론, 계속해서 추가되고, 수정되고 있다.
이 책은, "관례적이고 효과적인 자바 사용법"을 소개한다.
　   
    　   
      
### 자바는 "단일 상속 방식"의 "객체 지향" 언어이다.

메소드 안의 코드는 "명령 지향(문장 지향) 방식"으로 작성한다.
방대한 표준 라이브러리를 제공한다.
　   
    　   
        
### "관례적이고 효과적인 자바 사용법"은 무엇을 지향하는가?

1) 시공간적으로 효과적으로 작동하고
2) 팀 개발을 위해 타인이 이해하기 쉬운 코드를 작성해야 한다.
3) 또, 놓치기 쉬운 부분. "수정이 용이한 변경에 유연한 구조"여야한다.

개발을 해놓으면, 분명히 다음 버전에서 수정되는 부분이 생긴다. 그렇기에 개발을 할 때, 수정될 가능성이 있는 부분을 고려하여 수정되기 편한 구현 방식을 선택하는 것이 좋다.
　   
    　   
      
### 자바도 초반에는 간결한 언어였다. 신생 언어는 개발된 기능이 적기 때문이다.
하지만 지금의 자바는 방대하다. 많은 종속적인 확장, 라이브러리들이 추가되었다.
저자는, 이렇게 방대할수록 "모범 용법"이 이 시장에서 꼭 필요하다고 했다.
　   
    　   
      
### 자바의 수많은 라이브러리들은, 
 소프트웨어를 개발하는데 많은 이점을 가진다. 
 예) 품질, 생산성 향상
　   
    　   
      
 ### 이 책은 1,2,3판으로 이루어져 있다. 내가 읽은 책은 가장 최신의 3판이다. 2018년에 출판되었다.
　   
    　   
      　   
### 자바5에 추가된 내용
"제네릭(Generics)", "열거형(enum)", "애노테이션(Annotation)", "오토박싱(autoboxing)", for-each 반복문, 동시성 라이브러리(java.util.concurrency) 등이 추가되었다.
　   
    　   
             　   
### 자바9에서는 "모듈 시스템"이 추가되었다.
이는, 외부에서 접근 가능할(공개해줄) "package"를 선택해줄 수 있도록 "모듈"이라는 기능을 제공하는 것이다.
모듈은 기본적으로 캡슐화, 은닉되며, 내가 export to 등을 이용하여 공개 여부, 범위를 지정해줄 수 있다.
　   
    　   
        
### 현재는 자바17을 많이 사용하며, 2023-03-22 오라클에서 자바 20을 발표했다.
　   
    　   
       
### "리팩터링"의 핵심 목표는
시스템 구조 개선
중복 제거
이다.

이를 위해서, **"API를 잘 설계하는 것"**이 매우매우 중요하다.
이미 공개된 API는, 다른 사람들이 개발에 사용하고 있기 때문에 변경할 수 없다.
따라서 처음부터 API 설계를 잘 해야하는 것이다.
　   
    　   
      
### 아이템
이 책은 "아이템"이라는 개념을 사용한다. 총 90개의 아이템이 있다.
각 아이템당, "하나의 관례, 규칙"을 설명한다.
아이템들은 서로 독립적이다. 그래서 책을 읽을 때, 순서대로 읽지 않아도 된다.
아이템이 다른 아이템을 참조하기도 한다. 참조되는 순서대로 자유롭게 읽어도 된다.
　   
    　   
      
### 이 책의 관례들의 기본 규칙 2가지
1) 명료성(clarify), 2) 단순성(simplicity)
명료성은, 정해졌거나 예측할 수 있는 행동을 하는 것을 뜻한다. 예측 불가능한 행동은 규칙성을 깨고, 예외를 발생시키며, 사용자에게 혼돈을 준다.
단순성은, "컴포넌트"는 복사되지 않고 "재사용"되어야 하는데, 컴포넌트를 가능한 작게 쪼개야하는 것을 뜻한다. 그렇다고 너~무 작게 쪼개서도 안된다.
이 책에서 컴포넌트는, 메서드, 패키지, 프레임워크 등 재사용 가능한 모든 소프트웨어 요소를 뜻한다.
　   
    　   
      
### 이 책은 "디자인 패턴", "관용구"를 설명하기도 한다.
피해야 할 관행인 "안티패턴"도 등장한다.
　   
    　   
      
### 이 책은, 다음과 같은 용어를 사용한다.
1. 상속==서브 클래싱(subclassing)
2. 인터페이스 상속 == ('클래스'가 '인터페이스'를) "구현한다(implement)" / ('인터페이스'가 다른 '인터페이스'를) "확장한다(extend)"
3. API== 공개 API =="외부 패키지에서 접근할 수 있는 모든 클래스, 인터페이스, 생성자, 멤버, 직렬화된 데이터" == API 작성자가 클라이언트에게 접근이 가능하다고 약속해둔 API 요소들 == 'public' 또는 'protected' 또는 '생성자'가 해당됨
4. API 작성자==API의 사용자(user)
5. API를 사용하는 다른 클래스(코드) == API의 클라이언트(client)
6. API 요소 == 클래스, 인터페이스, 생성자, 멤버, 직렬화된 데이터
　   
    　   
      
 ### 직렬화, 역직렬화
직렬화(serialization) : 자바 데이터를 '바이트'로 변환한 것. 자바 외부에서도 사용하기 위함임
역직렬화(Deserialization) : 바이트 -> 자바 데이터
　   
    　   
      
### 자바의 접근제어자 4개
1) public : 모두가 접근 가능
2) protected : 패키지 내부, 자식 클래스에서 여기에 접근 가능
3) default(package-private) : 패키지 내부
4) private : 클래스 내부
　   
자바에서는 "접근 수준"을 명시하지 않았을 때, "default(package-private)" 접근 지정자가 붙는데, 해당 파일이 들어있는 '패키지 내부에서는 해당 파일에 접근 가능'하다는 뜻이다.
　   
    　   
      
### 오류는 가능하면 빠르게 수정되어야 한다. 
그래서, "컴파일 타임"에 오류를 인식할 수 있는 것이 비교적 좋은 오류인 것이다.
　   
    　   
      
### 자바의 자료형(type)

1) 인터페이스 ( ⊃ annotation, 사용자 정의 인터페이스 )
2) 클래스 ( ⊃ enum, 사용자 정의 인터페이스 )
3) 배열 ( array[] )
4) 기본타입(Primitive) ( int, float, char 등)
1,2,3-> "참조 타입(reference type)" ->"객체(object)"로 사용
4-> 객체로 사용 불가
　   
    　   
      
### 클래스(class)

클래스의 "멤버" : 필드(field), 메서드(method), 멤버 클래스, 멤버 인터페이스
멤버 클래스, 멤버 인터페이스 : 클래스 내에 구현하여 사용하는 것

### 메서드(method)
메서드 시그니처: 메서드 이름, 매개변수(parameter) (반환값의 type은 시그니처에 포함되지 않음!)
